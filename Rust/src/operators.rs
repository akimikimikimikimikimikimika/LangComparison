pub fn main() {
	println!("\r\nこれから演算子を試します\r\n");

	println!("\r\n算術演算子");
	println!("24   + 5   = {}",24  +5  );
	println!("24   - 5   = {}",24  -5  );
	println!("24   * 5   = {}",24  *5  );
	println!("24.0 / 5.0 = {}",24.0/5.0);
	println!("24   % 5   = {}",24  %5  );

	println!("\r\n比較演算子");
	println!("24 <  5 = {}",24 <  5);
	println!("24 <= 5 = {}",24 <= 5);
	println!("24 >  5 = {}",24 >  5);
	println!("24 >= 5 = {}",24 >= 5);
	println!("24 == 5 = {}",24 == 5);
	println!("24 != 5 = {}",24 != 5);

	println!("\r\n論理演算子");
	println!("true && false = {}",true && false);
	println!("true || false = {}",true || false);
	println!("      ! false = {}",      ! false);

	println!("\r\nビット演算子");
	println!("0b1010 & 0b1001 = 0b{:04b} (AND)",   0b1010 & 0b1001   );
	println!("0b1010 | 0b1001 = 0b{:04b} (OR)" ,   0b1010 | 0b1001   );
	println!("0b1010 ^ 0b1001 = 0b{:04b} (XOR)",   0b1010 ^ 0b1001   );
	println!("       ! 0b1001 = 0b{:04b} (NOT)",          ! 0b1001   +16);
	println!("");
	println!("0b00111111 << 2 = 0b{:08b} (2桁左シフト)",   0b00111111 << 2   );
	println!("0b00111111 >> 2 = 0b{:08b} (2桁右シフト)",   0b00111111 >> 2   );

}
/*
	ビット演算において,演算の内容を分かりやすくするため,意図的に本来の値から改変させたところがある
	• AND,OR,XOR,NOT においては,0埋めにより演算後も4桁が維持されるようにした (本来はない桁があったりする)
	• ビットシフトにおいては,0埋めにより演算後も8桁が維持されるようにした
	• NOT を通常通りに計算すると,これまでなかった桁も0と見做してビット反転するため,膨大な数になる。それを防止するため,5桁目以降を切り捨てる処理をした (右端の+16)
*/
/*
	その他に...
	複合代入演算子 : += -= *= /= %= &= |= ^= <<= >>=
		a += b は a = a + b と同義。その他も同様
*/