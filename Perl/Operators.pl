#! /usr/bin/env perl

print <<"Operators";

これから演算子を試します

算術演算子
24  + 5 = @{[   24  + 5   ]}
24  - 5 = @{[   24  - 5   ]}
24  * 5 = @{[   24  * 5   ]}
24  / 5 = @{[   24  / 5   ]}
24  % 5 = @{[   24  % 5   ]}
24 ** 5 = @{[   24 ** 5   ]}

数値比較演算子
24 >  5 = @{[   24  > 5   ]}
24 >= 5 = @{[   24 >= 5   ]}
24 <  5 = @{[   24  < 5   ]}
24 <= 5 = @{[   24 <= 5   ]}
24 == 5 = @{[   24 == 5   ]}
24 != 5 = @{[   24 != 5   ]}
24<=> 5 = @{[   24<=> 5   ]}
24<=>24 = @{[   24<=>24   ]}
 5<=>24 = @{[    5<=>24   ]}

論理演算子
1 and 0 = @{[   1 and 0   ]}
1  && 0 = @{[   1  && 0   ]}
1  or 0 = @{[   1  or 0   ]}
1  || 0 = @{[   1  || 0   ]}
1 xor 0 = @{[   1 xor 0   ]}
  not 0 = @{[     not 0   ]}
    ! 0 = @{[       ! 0   ]}

ビット演算子 (2進数での各桁毎の論理演算)
0b1010 & 0b1001 = 0b@{[sprintf("%04b",   oct("0b1010") & oct("0b1001")   )]} (AND)
0b1010 | 0b1001 = 0b@{[sprintf("%04b",   oct("0b1010") | oct("0b1001")   )]} (OR)
0b1010 ^ 0b1001 = 0b@{[sprintf("%04b",   oct("0b1010") ^ oct("0b1001")   )]} (XOR)
       ~ 0b1001 = 0b@{[sprintf("%04b",                 ~ oct("0b1001")   %16)]} (NOT)

0b00111111 << 2 = 0b@{[sprintf("%08b",   oct("0b00111111") << 2   )]} (2桁左シフト)
0b00111111 >> 2 = 0b@{[sprintf("%08b",   oct("0b00111111") >> 2   )]} (2桁右シフト)

三項演算子
1 ? "yes" : "no" = "@{[   1 ? "yes" : "no"   ]}"
0 ? "yes" : "no" = "@{[   0 ? "yes" : "no"   ]}"

文字列演算子
"abc" . "def" = "@{[   "abc" . "def"   ]}"
"abc" x 3     = "@{[   "abc" x 3       ]}"

文字列の別の表現
qq(a"b"c) = @{[   qq(a"b"c)   ]} (エスケープ不要)
q(that's) = @{[   q(that's)   ]} (エスケープ不要)

文字列比較演算子
"abc"  eq "def" = @{[   "abc"  eq "def"   ]} (等しい)
"abc"  ne "def" = @{[   "abc"  ne "def"   ]} (等しくない)
"abc"  lt "def" = @{[   "abc"  lt "def"   ]} (辞書順で "abc" < "def")
"abc"  le "def" = @{[   "abc"  le "def"   ]} (辞書順で "abc" ≦ "def")
"abc"  gt "def" = @{[   "abc"  gt "def"   ]} (辞書順で "abc" > "def")
"abc"  ge "def" = @{[   "abc"  ge "def"   ]} (辞書順で "abc" ≧ "def")
"abc" cmp "def" = @{[   "abc" cmp "def"   ]} (辞書順で "abc"<=>"def" を演算)

配列演算子
(1,2,3) x 3        = @{[   (1,2,3) x 3          ]}
(1,2,3) == (1,2,3) = @{[   (1,2,3) == (1,2,3)   ]}
(1,2) <=> (1,2,3)  = @{[   (1,2) <=> (1,2,3)    ]}

正規表現演算子
/[A-F]/ =~ "F" = @{[   /[A-F]/ =~ "F"   ]}
/[A-F]/ !~ "B" = @{[   /[A-F]/ !~ "B"   ]}
"F" =~ /[A-F]/ = @{[   "F" =~ /[A-F]/   ]}
"B" !~ /[A-F]/ = @{[   "B" !~ /[A-F]/   ]}

Operators

=comment
	XOR = eXclusive OR (排他的論理和)
	AND : 両方が 1(true) であれば, 1(true) になる
	XOR : 一方が 1(true) であれば, 1(true) になる
	 OR : 一方/両方が 1(true) であれば, 1(true) になる
	NOT : 1(true) と 0(false) を逆転させる

	ビット演算において,演算の内容を分かりやすくするため,意図的に本来の値から改変させたところがある
	• AND,OR,XOR,NOT においては,0埋めにより演算後も4桁が維持されるようにした (本来はない桁があったりする)
	• ビットシフトにおいては,0埋めにより演算後も8桁が維持されるようにした
	• NOT を通常通りに計算すると,これまでなかった桁も0と見做してビット反転するため,膨大な数になる。それを防止するため,5桁目以降を切り捨てる処理をした (右端の%16)
=cut

=comment
	その他に...
	複合代入演算子 : += -= *= /= %= **= &= |= ^= <<= >>= &&= ||=
		a += b は a= a + b と同義。その他も同様
	加算子/減算子: ++ --
		e.g.
			$a=5
			$b=$a++
			$a=5
			$c=++$a
			→ aは,1増加して 6 に変化し,bには加算前の 5 が代入され,cには加算後の 6 が代入される
=cut

print "\r\n\r\n";